---
sidebar_position: 2
description: Learn more about internationalization and translations.
---

# Internationalization

*Singularity*'s core design includes a robust, native Internationalization (i18n) system that allows any document type to support multiple language versions without complex joins or external databases. This is achieved through the **`Translatable`** interface and the **`TranslateService`**.

## 1. The Core Implementation

The entire system is built upon two core interfaces and one service component:

### The `Translatable<C>` Interface

Any domain model that needs to be multilingual must implement this interface. It acts as a contract, embedding all language versions directly within the main document.

```kotlin
interface Translatable<C> {
    // A map where the key is the language (Locale) and the value (C) is the content structure
    val translations: Map<Locale, C>
}
```

The generic type `C` represents the **Translation Model** (e.g., `ArticleTranslation`, `TagTranslation`), which is a simple data class holding the localized fields.

### The Translation Model (`C`)

This is a **data class** that holds all fields of the document that are intended to be translated. By separating these fields from the main document, you prevent data redundancy and keep the core metadata clean.

For example, the **`TagDocument`** uses `TagTranslation`:

| Field                            | Description                                              | Localization Status                  |
|:---------------------------------|:---------------------------------------------------------|:-------------------------------------|
| **`key`** (in `TagDocument`)     | The stable, unique identifier (e.g., `tech_news`).       | **NOT translated** (used for lookup) |
| **`name`** (in `TagTranslation`) | The displayed name of the tag (e.g., "Technology News"). | **Translated** (Language-specific)   |

### The `TranslateService`

This service acts as the central utility for fetching the correct language version of any `Translatable` object. Its main responsibility is to resolve the best possible translation based on the requested `Locale`.

```kotlin
// Main translation method
suspend fun <C> translate(translatable: Translatable<C>, locale: Locale?): Translation<C>
```

-----

## 2\. Advantages and Core Thoughts

### Advantage: Atomic & Cohesive Data

:::info Single Document Storage
All versions of an Article or a Tag (e.g., English, German, French) are stored together within a **single MongoDB document**. This means fetching the document is a single, efficient database operation, eliminating the need for costly joins or separate queries for related language tables.
:::

### Advantage: Automatic Fallback Resolution

The `TranslateService` provides intelligent fallback logic, ensuring a client always receives the most appropriate content, even if a perfect match isn't available:

1.  **Exact Match:** Tries to find the exact `Locale` match (e.g., `en-GB`).
2.  **Language Match:** Tries to find a match by language code (e.g., falls back to `en-US` if `en-GB` is not found).
3.  **Default Locale:** Falls back to the system's configured default `Locale`.
4.  **First Available:** As a final guarantee, it returns the first translation available in the map.

### Core Thought: Developer Experience

The translation implementation is largely decoupled from the primary service logic. Developers don't need to manually check locale or handle map lookups. They simply call `translateService.translate(...)`, and the business logic remains focused on the document's structure, not its language permutations.

-----

## 3\. Usage Example: Retrieving a Tag

To illustrate the usage, here's how the `TagService` resolves a multilingual Tag document for the client:

### A. The Document Structure

Assume a client requests a `TagDocument` with the key **`tech_news`** and a `Locale` of **`de-DE`**. The raw MongoDB document contains:

```kotlin
// TagDocument with two translations
val tagDocument = TagDocument(
    key = "tech_news",
    translations = mutableMapOf(
        Locale.ENGLISH to TagTranslation(name = "Technology News", description = "Latest from the tech world."),
        Locale.GERMAN to TagTranslation(name = "Technologie Nachrichten", description = "Aktuelles aus der Tech-Welt."),
    )
)
```

### B. The Translation Logic

The `TagService` would use the injected `translateService` to get the correct version:

```kotlin
@Service
class TagService(
    private val translateService: TranslateService,
    // ... other dependencies
) {
    suspend fun getLocalizedTag(tagKey: String, locale: Locale?): Translation<TagTranslation> {
        // 1. Fetch the multilingual document from the repository
        val tagDocument = findByKey(tagKey) 
        
        // 2. Resolve the best matching translation
        return translateService.translate(tagDocument, locale)
    }
}
```

### C. The Result

If the client requested `locale = Locale.GERMAN`, the service returns a **`Translation<TagTranslation>`** object:

```kotlin
Translation(
    locale = Locale.GERMAN, // The specific locale that was matched
    translation = TagTranslation( 
        name = "Technologie Nachrichten", 
        description = "Aktuelles aus der Tech-Welt."
    )
)
```

:::note Resource Bundle Translation
The `TranslateService` also includes a helper function, **`translateResourceKey`**, which is used for translating static keys (like error messages or UI labels) that are stored in standard Java Resource Bundles (`.properties` files), completing the framework's i18n capabilities.
:::